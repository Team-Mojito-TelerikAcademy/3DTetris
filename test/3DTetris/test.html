<!DOCTYPE html>
<html>
<head lang="en">

    <title>3D Tetris</title>

</head>
<body>
<div id="viewport"></div>

<script src="js/three.min.js"></script>
<script src="http://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="scripts/tetris3d.js"></script>

<script>


    var shapes = [
        [
            {x: 0, y: 0, z: 0},
            {x: 1, y: 0, z: 0},
            {x: 1, y: 1, z: 0},
            {x: 1, y: 2, z: 0}
        ],
        [
            {x: 0, y: 0, z: 0},
            {x: 0, y: 1, z: 0},
            {x: 0, y: 2, z: 0},
        ],
        [
            {x: 0, y: 0, z: 0},
            {x: 0, y: 1, z: 0},
            {x: 1, y: 0, z: 0},
            {x: 1, y: 1, z: 0}
        ],
        [
            {x: 0, y: 0, z: 0},
            {x: 0, y: 1, z: 0},
            {x: 0, y: 2, z: 0},
            {x: 1, y: 1, z: 0}
        ],
        [
            {x: 0, y: 0, z: 0},
            {x: 0, y: 1, z: 0},
            {x: 1, y: 1, z: 0},
            {x: 1, y: 2, z: 0}
        ]
    ];

    var Colors = [
        0x6666ff, 0x66ffff, 0xcc68EE, 0x666633, 0x66ff66, 0x9966ff, 0x00ff66, 0x66EE33, 0x003399, 0x330099, 0xFFA500, 0x99ff00, 0xee1289, 0x71C671, 0x00BFFF, 0x666633, 0x669966, 0x9966ff
    ];


    cloneVector = function (v) {
        return {x: v.x, y: v.y, z: v.z};
    };

    function getBlockStartPosition(boardSizeX, blockSize) {
        //FIXME: This probably can be made smarter right ?
        return Math.abs(Math.floor(Math.floor(Math.random() * boardSizeX)  / blockSize) - 1) * blockSize + (blockSize / 2);
    }

    var container;
    var camera, controls, scene, renderer;
    var plane, cube;
    var mouse, raycaster, isShiftDown = false;
    var mouse2D;
    var Block;

    var rollOverMesh, rollOverMaterial;
    var cubeGeo, cubeMaterial;

    var objects = [];

    init();
    animate();
    render();

    function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.position.set( 1500, 1800, 1800 );
        camera.lookAt( new THREE.Vector3() );

        renderer = new THREE.WebGLRenderer( { antialias: true } );

        controls = new THREE.OrbitControls( camera );
        controls.damping = 0.2;
        controls.addEventListener( 'change', render );

        scene = new THREE.Scene();
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        var geometry, tmpGeometry;

        var type = Math.floor(Math.random() * (shapes.length));
        this.blockType = type;

        var blockSize = 100;

        // the current shape
        Block = {};
        Block.position = {};
        Block.shape = [];

        Block.move = function(x, y, z) {

            Block.mesh.position.x += x * blockSize;
            Block.position.x += x;
            Block.mesh.position.y += y * blockSize;
            Block.position.y += y;
            Block.mesh.position.z += z * blockSize;
            Block.position.z += z;
        }

        for (var i = 0; i < shapes[type].length; i++) {
            Block.shape[i] = cloneVector(shapes[type][i]);
        }

        // the glue :D
        function buildBlockMesh() {

            var texture = THREE.ImageUtils.loadTexture( 'textures/crate.gif' );
            texture.anisotropy = renderer.getMaxAnisotropy();

            randColor = Colors[Math.floor(Math.random() * Colors.length)];

            geometry = new THREE.Mesh(
                    new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                    new THREE.MeshBasicMaterial({ map: texture }, .9,.0)
            );
            for (var i = 1; i < Block.shape.length; i++) {
                tmpGeometry = new THREE.Mesh(new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                        new THREE.MeshBasicMaterial({ map: texture }),
                        10);
                tmpGeometry.position.x = blockSize * Block.shape[i].x;
                tmpGeometry.position.y = blockSize * Block.shape[i].y;

                geometry.add(tmpGeometry);
                // Next lines are not supported in Physijs
                //tmpGeometry.updateMatrix();
                //geometry.merge(tmpGeometry.geometry, tmpGeometry.matrix);
                //THREE.GeometryUtils.merge(geometry, tmpGeometry);
            }

            geometry.position.y += blockSize / 2;

            return geometry;
        }



        // roll-over helpers

        //rollOverGeo = new THREE.BoxGeometry( 100, 100, 100 );
        // rollOverMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true } );
        // rollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );
        // rollOverMesh.position.y += 800;
        // scene.add( rollOverMesh );

        // cubes

        cubeGeo = new THREE.BoxGeometry( 50, 50, 50 );
        cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xfeb74c, shading: THREE.FlatShading, map: THREE.ImageUtils.loadTexture( "textures/square-outline-textured.png" ) } );

        // grid

        var size = 500, step = 100;

        var geometry = new THREE.Geometry();

        for ( var i = -size; i <= size; i += step ) {

            geometry.vertices.push( new THREE.Vector3( - size + 500, 0, i + 500 ) );
            geometry.vertices.push( new THREE.Vector3(   size + 500, 0, i + 500 ) );

            geometry.vertices.push( new THREE.Vector3( i + 500, 0, - size + 500 ) );
            geometry.vertices.push( new THREE.Vector3( i + 500, 0,   size + 500) );

        }

        var material = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2, transparent: true } );

        var line = new THREE.Line( geometry, material, THREE.LinePieces );
        scene.add( line );

        //

        var geometry = new THREE.PlaneBufferGeometry( 1000, 1000 );
        geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

        plane = new THREE.Mesh( geometry );
        plane.position.x += 500;
        plane.position.z += 500;
        plane.visible = true;
        scene.add( plane );

        objects.push( plane );

        // Lights

        var ambientLight = new THREE.AmbientLight( 0x606060 );
        scene.add( ambientLight );

        var directionalLight = new THREE.DirectionalLight( 0xffffff );
        directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
        scene.add( directionalLight );


        renderer.setClearColor( 0xf0f0f0 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        mouse2D = new THREE.Vector3( 0, 10000, 0.5 );

        Block.mesh = buildBlockMesh();

        Block.mesh.position.x = getBlockStartPosition(1000, blockSize);
        Block.mesh.position.y += 1000;
        Block.mesh.position.z = getBlockStartPosition(1000, blockSize);

     //   console.log("mesh.x: " + Block.mesh.position.x + " mesh.z: " + Block.mesh.position.z);
       // Block.mesh.position.y += 800;
        objects.push(Block.mesh);
        scene.add(Block.mesh);
        //document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        //  document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        //  document.addEventListener( 'keydown', onDocumentKeyDown, false );
        //   document.addEventListener( 'keyup', onDocumentKeyUp, false );

        //

        // window.addEventListener( 'resize', onWindowResize, false );

    }


    function onDocumentMouseDown( event ) {


        event.preventDefault();

        mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

        raycaster.setFromCamera( mouse, camera );

        var intersects = raycaster.intersectObjects( objects );

        if ( intersects.length > 0 ) {

            var intersect = intersects[ 0 ];

            // delete cube

            if ( isShiftDown ) {

                if ( intersect.object != plane ) {

                    scene.remove( intersect.object );

                    objects.splice( objects.indexOf( intersect.object ), 1 );

                }

                // create cube

            } else {

                var voxel = new THREE.Mesh( cubeGeo, cubeMaterial );
                voxel.position.copy( intersect.point ).add( intersect.face.normal );
                voxel.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );

                scene.add( voxel );

                objects.push( voxel );
                console.log(voxel.position.z);

            }

            render();

        }

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function render() {

        renderer.render( scene, camera );

    }

    var lastFrameTime = Date.now();
    var gameStepTime = 1000;
    var frameTimeDifference = 0;

    function animate() {

        var time = Date.now();
        frameTimeDifference += time - lastFrameTime;
        lastFrameTime = time;

        while (frameTimeDifference > gameStepTime) {

            frameTimeDifference -= gameStepTime;
            Block.move(0, -1, 0);
            render();
        }

        controls.update();
        requestAnimationFrame(animate);
    }

</script>
</body>
</html>